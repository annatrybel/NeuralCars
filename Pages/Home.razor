@page "/"
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using NeuralCars
@inject IJSRuntime JsRuntime

<PageTitle>Neuroewolucja Aut</PageTitle>

<div class="container text-center mt-3">
    <h3>Generacja: <strong>@Generation</strong> | Czas: <strong>@CurrentFrame / @MaxFrames</strong> | Żywych: <strong>@AliveCount</strong></h3>

    <div style="border: 2px solid #333; display: inline-block;">
        <BECanvas Width="800" Height="600" @ref="_canvasReference"></BECanvas>
    </div>

    <div class="mt-2">
        <button class="btn btn-success" @onclick="StartSimulation" disabled="@IsRunning">Start</button>
        <button class="btn btn-danger" @onclick="StopSimulation">Stop</button>
        <button class="btn btn-warning" @onclick="ResetSimulation">Reset</button>
    </div>
</div>

@code {
    private BECanvas _canvasReference;
    private Canvas2DContext _context;

    private bool IsRunning = false;
    private int Generation = 1;
    private double BestFitness = 0;
    private int AliveCount = 0;
    private int CurrentFrame = 0;
    private const int MaxFrames = 2000;

    private List<Car> Cars = new List<Car>();
    private const int PopulationSize = 20;

    private List<(double X, double Y)> Checkpoints = new List<(double X, double Y)>
    {
        (100, 100), (400, 50), (700, 100), (750, 300),
        (700, 500), (400, 550), (100, 500), (50, 300)
    };

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _context = await _canvasReference.CreateCanvas2DAsync();
            InitializePopulation();
            await DrawFrame();
        }
    }

    private void InitializePopulation()
    {
        Cars.Clear();
        for (int i = 0; i < PopulationSize; i++)
        {
            Cars.Add(new Car());
        }
        Generation = 1;
        CurrentFrame = 0;
        BestFitness = 0;
        AliveCount = PopulationSize;
    }

    private async Task StartSimulation()
    {
        if (IsRunning) return;
        IsRunning = true;
        await GameLoop();
    }

    private void StopSimulation() => IsRunning = false;

    private void ResetSimulation()
    {
        IsRunning = false;
        InitializePopulation();
        StateHasChanged();
    }

    private async Task GameLoop()
    {
        while (IsRunning)
        {
            CurrentFrame++;

            bool allDead = true;
            AliveCount = 0;

            foreach (var car in Cars)
            {
                car.Update(Checkpoints);
                if (!car.IsDead)
                {
                    allDead = false;
                    AliveCount++;
                }
                if (car.Fitness > BestFitness) BestFitness = car.Fitness;
            }

            if (allDead || CurrentFrame >= MaxFrames)
            {
                EvolveNextGeneration();
            }

            await DrawFrame();

            StateHasChanged(); 
            await Task.Delay(16); 
        }
    }

    private void EvolveNextGeneration()
    {
        var sortedCars = Cars.OrderByDescending(c => c.Fitness).ToList();
        BestFitness = sortedCars.First().Fitness;

        var newCars = new List<Car>();

        var championBrain = new NeuralNetwork(sortedCars[0].Brain);
        var championCar = new Car(championBrain); 
        newCars.Add(championCar);

        // reprodukcja i krzyżowanie
        Random rand = new Random();
        while (newCars.Count < PopulationSize)
        {
            var parent1 = sortedCars[rand.Next(0, PopulationSize / 2)];
            var parent2 = sortedCars[rand.Next(0, PopulationSize / 2)];

            var childBrain = NeuralNetwork.Crossover(parent1.Brain, parent2.Brain);

            childBrain.Mutate(0.1);

            var childCar = new Car(childBrain);
            newCars.Add(childCar);
        }

        Cars = newCars;
        CurrentFrame = 0;
        Generation++;
    }

    private async Task DrawFrame()
    {
        await _context.BeginBatchAsync();

        await _context.ClearRectAsync(0, 0, 800, 600);

        await _context.SetFillStyleAsync("#f0f0f0");
        await _context.FillRectAsync(0, 0, 800, 600);

        // Checkpointy
        await _context.SetFillStyleAsync("rgba(0, 255, 0, 0.2)");
        foreach (var cp in Checkpoints)
        {
            await _context.BeginPathAsync();
            await _context.ArcAsync(cp.X, cp.Y, 20, 0, Math.PI * 2);
            await _context.FillAsync();
        }

        foreach (var car in Cars)
        {
            await _context.SaveAsync();
            await _context.TranslateAsync((float)car.X, (float)car.Y);
            await _context.RotateAsync((float)car.Angle);

            if (car.IsDead)
            {
                await _context.SetFillStyleAsync("rgba(255, 0, 0, 0.3)");
            }
            else
            {
                await _context.SetFillStyleAsync("blue");
            }

            await _context.FillRectAsync(-20, -10, 40, 20);

            await _context.SetFillStyleAsync("yellow");
            await _context.FillRectAsync(10, -8, 5, 5);
            await _context.FillRectAsync(10, 3, 5, 5);

            await _context.RestoreAsync();
        }

        await _context.EndBatchAsync();
    }
}